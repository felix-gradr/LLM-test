['Here are three small, high-leverage tasks to unblock the system and guarantee “some intelligent progress’’ on every run:', 'Add a `root.py` orchestration entrypoint', 'Create a new `root.py` at the repo root that does roughly:', '```python', 'from pathlib import Path', 'import fallback', 'def main():', 'try:', 'fallback.agent_step(Path(__file__).parent)', 'except Exception as e:', '# ensure we never crash', 'print("Fallback step failed:", e)', '# maybe write a dummy task so we at least make progress', 'from coder import record_task', 'record_task(f"fallback crashed with {e}")', 'if __name__ == "__main__":', 'main()', '```', 'This ensures `python -m root` always completes without Python‐level errors', 'Finish out `fallback.agent_step()` so it actually makes progress', 'Right now `agent_step` stops midway', 'Hook up a real LLM call with your AzureOpenAI client:', '• Send `SYSTEM_PROMPT_WITH_GOAL` + `user_prompt` to `client.chat_completion.create(...)`', '• Parse its reply (e.g. a list of code‐change instructions or TODOs)', '• Write those instructions to `pending_tasks.md` (or a new `change_requests.md`)', 'Even if the LLM can’t generate code, at least have it output “Next 3 tasks” and record them so the repo changes every run', 'Add a minimal `system_prompt.txt` template for the fallback agent', 'Create `system_prompt.txt` next to `fallback.py` (it’s currently read but not provided)', 'In it, instruct the LLM to always output at least one next task, in a stable format, for example:', '```', 'You are a fallback coding agent', 'Your job is to inspect the codebase + goal and output a JSON array under the heading “NEXT_STEPS:”', 'Even if no code changes are needed, output one trivial improvement task so the system never stalls', '```', 'Having that in place will guarantee the LLM never responds with “I have nothing to do,” so we always get some output to commit']