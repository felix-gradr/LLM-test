[
  "Here are three small, high-impact tasks to get us unstuck and driving continuous progress:",
  "Build a minimal orchestrator (`root.py`)",
  "Create `root.py` at the project root with a `main()` that:",
  "\u2022 Reads the GOAL from `goal.md`",
  "\u2022 Loads any outstanding `pending_tasks.md` entries",
  "\u2022 If there are no pending tasks, calls a planning routine (see Task 2)",
  "\u2022 Otherwise picks the oldest task, calls `coder.apply_task(...)`, and on success removes it from `pending_tasks.md`",
  "\u2022 Logs each iteration to a simple `iteration_log.md`",
  "Wire up `if __name__ == \"__main__\": main()` so that `python -m root` runs it",
  "Add a lightweight LLM-backed planner in `root.py`",
  "Inside `root.py`, implement `plan_new_tasks()` that:",
  "\u2022 Invokes `llm_utils.chat_completion` with a system message embedding the GOAL, a short codebase snapshot, and \u201cYou\u2019re an agent planning the next 3 tiny tasks toward this goal.\u201d",
  "\u2022 Parses the reply into a bullet-list of 3 one-sentence tasks",
  "\u2022 Calls `coder.record_task(task)` for each bullet",
  "Ensure that `main()` calls `plan_new_tasks()` when there are no pending tasks",
  "Hook in a bare-bones fallback recovery",
  "In `root.py` wrap your `main()` logic in a try/except. On any exception:",
  "\u2022 `import fallback` and call a newly defined `fallback.main(error_traceback)`",
  "In `fallback.py` add:",
  "\u2022 A `def main(error: str):` entrypoint",
  "\u2022 That writes the traceback to `fallback.log` with a timestamp",
  "\u2022 And appends a generic \u201cRecover from error\u201d task to `pending_tasks.md` so the next run still has something to do",
  "These three tasks will give us a loop that (a) never crashes without registering recovery work, (b) actually plans and executes something each iteration, and (c) ensures intelligent LLM-based forward motion. Once this is in place, we can iterate on making the planner smarter and the fallback more self-healing"
]