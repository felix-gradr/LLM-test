[
  "Here are three small, high-impact tasks that will get us basic error logging in place without touching `goal.md` or `.env`.  Once these land, any downstream error (in your main loop, in `coder`, or in `fallback`) will at least be captured in a log file so we can iterate on a \u201ccurrent issues\u201d dashboard later",
  "Add a simple centralized logger",
  "Create a new module (e.g. `root/logger.py`) that on import runs something like:",
  "```python",
  "import logging, os",
  "os.makedirs(\"logs\", exist_ok=True)",
  "logging.basicConfig(",
  "filename=\"logs/error.log\",",
  "level=logging.INFO,",
  "format=\"%(asctime)s %(levelname)s %(name)s: %(message)s\",",
  ")",
  "```",
  "Export a `get_logger(name)` helper so any other module can do `logger = get_logger(__name__)`",
  "Instrument `root.py`\u2019s main entrypoint with try/except",
  "In your `if __name__ == \"__main__\":` (or wherever the main loop lives),",
  "wrap the entire drive sequence in",
  "```python",
  "from root.logger import get_logger",
  "logger = get_logger(\"root\")",
  "try:",
  "main()   # whatever your startup function is",
  "except Exception:",
  "logger.exception(\"Unhandled exception in main loop\")",
  "# Optionally re-raise or exit(1)",
  "```",
  "This guarantees _any_ crash in root gets logged into `logs/error.log`",
  "Swap print/traceback in `coder.apply_task` for structured logging",
  "In `coder.py`, import `logging` (or your `get_logger`) instead of `print_exc()`, then inside the `except Exception as e:` block do:",
  "```python",
  "logger = logging.getLogger(\"coder\")",
  "logger.exception(\"Error applying task %r\", task)",
  "```",
  "That replaces the console\u2010only traceback with a persistent log entry",
  "Once these three bite\u2010sized changes are in place, rerunning `python -m root` will always drop any failures into `logs/error.log`, giving us a foothold to build out the \u201ccurrent issues\u201d system next"
]