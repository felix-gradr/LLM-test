[
  "Here are three small, high-leverage tasks to get basic error\u2010logging wired in across the codebase:",
  "Create a central logger configuration",
  "\u2022 Add a new module (e.g. `error_logger.py`) that does something like:",
  "```python",
  "import logging",
  "def get_logger(name=None):",
  "logger = logging.getLogger(name)",
  "if not logger.handlers:",
  "handler = logging.FileHandler(\"error.log\", encoding=\"utf-8\")",
  "fmt = logging.Formatter(",
  "\"%(asctime)s %(levelname)-8s [%(name)s] %(message)s\",",
  "datefmt=\"%Y-%m-%dT%H:%M:%S\",",
  ")",
  "handler.setFormatter(fmt)",
  "logger.addHandler(handler)",
  "logger.setLevel(logging.DEBUG)",
  "return logger",
  "```",
  "\u2022 This gives us one file (`error.log`) where everything winds up",
  "Wire it into `coder.py`",
  "\u2022 Import the central logger and replace the current `print_exc()` + silent failure with `logger.exception(...)`",
  "\u2022 Log both the task name and full stack trace on error. Also log \u201ctask succeeded\u201d at INFO level",
  "\u2022 Example snippet inside `apply_task`:",
  "```python",
  "from error_logger import get_logger",
  "logger = get_logger(__name__)",
  "try:",
  "exec(reply, {...})",
  "logger.info(\"apply_task succeeded: %s\", task)",
  "except Exception:",
  "logger.exception(\"apply_task failed: %s\", task)",
  "```",
  "Wrap the top\u2010level entrypoints",
  "\u2022 In `root.py` (and likewise in `fallback.py`), surround the main orchestration with one big `try/except Exception as e:` block",
  "\u2022 On any uncaught error, do `logger = get_logger(__name__)` then `logger.exception(\"Uncaught error in main: %s\", e)` before exiting",
  "\u2022 This guarantees *any* crash\u2014LLM or Python\u2014gets recorded to `error.log`"
]