[
  "Here are three bite-sized, high-impact tasks that will kick-start your long-term strategy and enforce \u201cno repeats\u201d by logging exactly what changed each run:",
  "Add a change-logger module",
  "Create a new file (e.g. `change_logger.py`) that, given a \u201cbefore\u201d and \u201cafter\u201d snapshot of all `.py` files, runs a `difflib.unified_diff` and appends a concise summary (filename + diff snippet) to `change_log.md`",
  "This will let every iteration leave a human\u2010readable summary of \u201cwhat actually changed.\u201d",
  "Implement an iteration tracker",
  "Introduce a persistent counter and metadata store (e.g. `iteration_state.json`). On each run, increment the counter, record timestamp, the list of tasks applied, and pull in that diff snippet from `change_log.md`",
  "Expose simple APIs in a new `iteration_tracker.py` module for \u201cget_current_iteration()\u201d and \u201crecord_iteration(summary_dict).\u201d",
  "Wire everything into the main runner",
  "Update your entrypoint (`root.py` or `seed.py`) so that at the end of every run it:",
  "a) takes a fresh backup of the codebase before making changes",
  "b) calls the coder to fulfill any new tasks",
  "c) invokes the change-logger to generate the diff snippet",
  "d) calls the iteration tracker to record that iteration\u2019s metadata",
  "This ensures every run automatically produces both a changelog snippet and a record, preventing silent repeats"
]