[2025-07-18T23:52:40] {"action": "create_files", "changes": [{"path": "loop_protection.py", "content": "from __future__ import annotations\n\n\"\"\"Loop-protection utilities for SelfCoder.\n\nThe purpose of this helper is to detect *identical* action payloads across\nconsecutive iterations.  If the agent keeps proposing exactly the same JSON\n(e.g. because the LLM got stuck), we can short-circuit the cycle early and thus\nfulfil the *Current Sub-goal* requirement of avoiding infinite loops.\n\nThe implementation purposefully has **zero** external dependencies and is\nlightweight so that importing it inside *root.py* adds negligible risk.\n\nDesign goals\n============\n1. No modification of the memory format – we only **read** the existing\n   structured JSONL or legacy flat log.\n2. Graceful degradation – if anything goes wrong, simply return *False* so we\n   never block progress because of a bug here.\n3. Minimal footprint – a single file, pure stdlib.\n\"\"\"\n\nfrom pathlib import Path\nimport json\nfrom typing import Any, Dict\n\ntry:\n    # Optional dependency – *root.py* may run without the structured manager\n    from memory_manager import Memory  # type: ignore\nexcept Exception:\n    Memory = None  # noqa: N816 (constant-like alias)\n\n# ---------------------------------------------------------------------------\n# Helper class (namespace-style)\n# ---------------------------------------------------------------------------\nclass LoopProtector:\n    \"\"\"Static helpers to detect and mitigate repeated identical actions.\"\"\"\n\n    _LEGACY_MEMORY_PATH: Path = Path(__file__).parent / \"memory.log\"\n\n    # ----------------------------- Public API -----------------------------\n    @staticmethod\n    def is_redundant(actions: Dict[str, Any]) -> bool:  # noqa: D401 – imperative style\n        \"\"\"Return *True* if *actions* exactly matches the last stored action.\n\n        The comparison is performed on a *stable* JSON representation (keys\n        sorted) so re-ordering inside dictionaries does not matter.\n        \"\"\"\n        try:\n            last_raw = LoopProtector._last_action_raw()\n            if last_raw is None:\n                return False\n            last_obj = json.loads(last_raw)\n            return LoopProtector._stable(last_obj) == LoopProtector._stable(actions)\n        except Exception:\n            # Any failure -> assume *not* redundant to avoid false positives\n            return False\n\n    # --------------------------- Internal helpers -------------------------\n    @staticmethod\n    def _stable(obj: Dict[str, Any]) -> str:\n        \"\"\"Return canonical JSON (sorted keys, no whitespace).\"\"\"\n        return json.dumps(obj, sort_keys=True, separators=(\",\", \":\"), ensure_ascii=False)\n\n    @staticmethod\n    def _last_action_raw() -> str | None:\n        \"\"\"Fetch the *raw* JSON string of the most recent 'action' record.\"\"\"\n        # Preferred: structured memory\n        if Memory is not None:\n            try:\n                for rec in reversed(Memory.load()):\n                    if rec.get(\"type\") == \"action\":\n                        return rec.get(\"content\")  # type: ignore[return-value]\n            except Exception:\n                pass  # fall back to legacy\n\n        # Legacy fallback – iterate the flat log in reverse\n        path = LoopProtector._LEGACY_MEMORY_PATH\n        if not path.is_file():\n            return None\n        try:\n            lines = path.read_text(encoding=\"utf-8\", errors=\"ignore\").splitlines()\n            for ln in reversed(lines):\n                ln = ln.strip()\n                if not ln:\n                    continue\n                try:\n                    candidate = json.loads(ln)\n                except json.JSONDecodeError:\n                    continue\n                if isinstance(candidate, dict) and \"action\" in candidate:\n                    return ln\n        except Exception:\n            pass  # silent – better be permissive\n        return None\n"}, {"path": "root.py", "content": "from __future__ import annotations\n\nimport json\nimport os\nfrom dotenv import load_dotenv\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom openai import AzureOpenAI\n\n# --- NEW ---------------------------------------------------------------\n# Prefer the new structured memory manager but keep legacy log for\n# backward-compatibility & easy grepping.  This staged approach minimises\n# risk while we port existing features.\ntry:\n    from memory_manager import Memory  # type: ignore\nexcept Exception as exc:  # pragma: no cover – should never fail\n    Memory = None  # fallback handled later\n    print(\"[WARN] Failed to import memory_manager –\", exc)\n\n# Loop-protection (may be absent on very first run)\ntry:\n    from loop_protection import LoopProtector  # type: ignore\nexcept Exception as exc:  # pragma: no cover\n    LoopProtector = None\n    print(\"[WARN] Failed to import loop_protection –\", exc)\n# ----------------------------------------------------------------------\n\nload_dotenv(override=True)\n\n# File types that the agent is allowed to read/write.  Adjust as needed.\nCODE_EXTENSIONS = {\".py\", \".txt\", \".md\"}\n\n# Legacy flat-text memory file (kept for now).\nMEMORY_PATH = Path(__file__).parent / \"memory.log\"\nMEMORY_CHAR_LIMIT = 4000  # ~ 1k tokens\n\n# Load SYSTEM_PROMPT from prompt.txt\nSYSTEM_PROMPT = (Path(__file__).parent / \"system_prompt.txt\").read_text(encoding=\"utf-8\").strip()\n\n# Load goal from goal.md\nGOAL = (Path(__file__).parent / \"goal.md\").read_text(encoding=\"utf-8\").strip()\n\n\n# ---------------------------------------------------------------------------\n# Helper functions – filesystem & .gitignore handling (unchanged)\n# ---------------------------------------------------------------------------\n\n\n[...UNCHANGED CONTENT OF ROOT.PY UNTIL THE POINT JUST AFTER json.loads(reply)...]\n\n    try:\n        actions = json.loads(reply)\n    except json.JSONDecodeError:\n        print(\"[WARN] LLM returned invalid JSON. Skipping iteration.\")\n        return\n\n    # ------------------------------------------------------------------\n    # Loop-protection: skip if the exact same payload was seen last time\n    # ------------------------------------------------------------------\n    if LoopProtector is not None and LoopProtector.is_redundant(actions):\n        print(\"[AGENT] Repeated identical action detected; preventing potential loop.\")\n        _append_memory(\"Skipped repeated identical action\", entry_type=\"reflection\")\n        return\n\n    action = actions.get(\"action\")\n    if action in {\"modify_files\", \"create_files\", \"append_files\"}:\n        apply_changes(root, actions.get(\"changes\", []))\n        _append_memory(json.dumps(actions, ensure_ascii=False), entry_type=\"action\")\n    elif action == \"human_help\":\n        print(\"[AGENT] Requests human assistance:\\n\" + actions.get(\"message_to_human\", \"\"))\n    elif action == \"no_op\":\n        print(\"[AGENT] No changes proposed this iteration.\")\n    else:\n        print(f\"[WARN] Unknown action '{action}'. Skipping.\")\n\n    # Delete seed.txt (only relevant for the first run)\n    seed_file = root / \"seed.txt\"\n    if seed_file.exists():\n        seed_file.unlink()\n        print(f\"[{datetime.utcnow().isoformat(timespec='seconds')}] Deleted {seed_file}\")\n"}]}
