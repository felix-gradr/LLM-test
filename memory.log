[2025-07-18T23:45:04] {
  "action": "create_files",
  "changes": [
    {
      "path": "memory_manager.py",
      "content": "from __future__ import annotations\n\n\"\"\"Structured memory utilities for SelfCoder.\n\nThis module centralises memory handling so that other parts of the codebase\ncan benefit from higher-level operations (appending typed entries, searching,\nsummarising, etc.).  It is **deliberately** independent from the core loop so\nthat root.py does not need to change right away – we can integrate gradually\n& safely.\n\nRationale\n---------\nThe existing implementation in *root.py* stores plain text lines in\n``memory.log``.  That works, but it is difficult to query or build features\n(like long-term planning, searching for past mistakes, detecting infinite\nloops ...).  The structured JSONL format introduced here remains completely\nappend-only and therefore safe, yet it unlocks richer capabilities.\n\nDesign goals\n============\n1. **Backward compatible** – the legacy *memory.log* is left untouched for\n   now so nothing breaks.\n2. **Append-only** – we never rewrite history.\n3. **Low risk** – no external dependencies; pure stdlib.\n\nTypical usage\n-------------\n>>> from memory_manager import Memory\n>>> Memory.append('reflection', 'I should avoid repeating the same bug')\n>>> last = Memory.load(last_n=3)\n>>> excerpt = Memory.summarise(max_chars=4000)\n\"\"\"\n\nfrom dataclasses import dataclass, asdict\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nimport json\nfrom typing import Literal, List, Dict\n\n# ---------------------------------------------------------------------------\n# Public, easy-to-use façade\n# ---------------------------------------------------------------------------\n\nEntryType = Literal[\n    \"plan\",       # long-term planning or next-steps\n    \"action\",     # changes applied in an iteration\n    \"observation\",# world or codebase observations\n    \"reflection\", # meta level thoughts / lessons learned\n]\n\n\nclass Memory:\n    \"\"\"Namespace-style utility class (static methods only).\"\"\"\n\n    # Location of the new structured memory file.\n    _PATH: Path = Path(__file__).parent / \"memory.jsonl\"\n    # Safety cap: avoid loading a gigantic file into RAM during summarisation.\n    _SUMMARY_CHAR_LIMIT: int = 8000  # ~2k tokens\n\n    # -------------------------- Low-level helpers --------------------------\n    @staticmethod\n    def _timestamp() -> str:\n        \"\"\"Return an ISO8601 timestamp in UTC, truncated to seconds.\"\"\"\n        return datetime.now(timezone.utc).replace(microsecond=0).isoformat()\n\n    # -------------------------- Public helpers ----------------------------\n    @staticmethod\n    def append(entry_type: EntryType, content: str) -> None:\n        \"\"\"Append a typed entry to *memory.jsonl* (one JSON per line).\"\"\"\n        Memory._PATH.parent.mkdir(parents=True, exist_ok=True)\n        record = {\n            \"ts\": Memory._timestamp(),\n            \"type\": entry_type,\n            \"content\": content.strip(),\n        }\n        with Memory._PATH.open(\"a\", encoding=\"utf-8\") as f:\n            f.write(json.dumps(record, ensure_ascii=False) + \"\\n\")\n\n    @staticmethod\n    def load(last_n: int | None = None) -> List[Dict]:\n        \"\"\"Return the last *n* records (or all if *None*).\n\n        The order is preserved (old->new).\n        \"\"\"\n        if not Memory._PATH.is_file():\n            return []\n        with Memory._PATH.open(\"r\", encoding=\"utf-8\") as f:\n            lines = f.readlines()\n        if last_n is not None:\n            lines = lines[-last_n:]\n        return [json.loads(ln) for ln in lines]\n\n    @staticmethod\n    def summarise(max_chars: int | None = None) -> str:\n        \"\"\"Return a *plain text* excerpt of the most recent records.\n\n        Concatenates the *content* fields in chronological order until\n        *max_chars* (default: internal limit) is reached.  This is intended to\n        be fed back into the LLM as the MEMORY excerpt.\n        \"\"\"\n        max_chars = max_chars or Memory._SUMMARY_CHAR_LIMIT\n        records = Memory.load()\n        excerpt_parts: List[str] = []\n        # Start from the end (newest) but build the excerpt reversed later.\n        current_len = 0\n        for rec in reversed(records):\n            text = f\"[{rec['ts']}] ({rec['type']}) {rec['content']}\"\n            new_len = current_len + len(text) + 1  # +1 for newline\n            if new_len > max_chars:\n                break\n            excerpt_parts.append(text)\n            current_len = new_len\n        # We iterated backwards, so restore chronological order.\n        excerpt = \"\\n\".join(reversed(excerpt_parts))\n        return excerpt\n"
    },
    {
      "path": "plan.md",
      "content": "# SelfCoder – Long-Term Plan\n\nThis document is **mutable** and acts as the high-level roadmap that spans\nmultiple iterations.  It should be updated *incrementally* – big-bang edits\nare discouraged because they hide context in the diff.\n\n## Phase 1 – Core Infrastructure (current)\n\nGoal: fulfil the *Current Sub-goal* outlined in `goal.md` – memory, safety,\nloop-protection.\n\n- [x] Introduce structured memory (`memory_manager.py`).\n- [ ] Wire the new memory manager into `root.py` (safe, staged rollout).\n- [ ] Devise & implement loop-protection heuristics (detect identical diffs).\n- [ ] Add lightweight tests to protect critical files from accidental damage.\n\n## Phase 2 – Self-Improvement Framework\n\nGoal: iterate on plans, tests, and analysis to continuously enhance the agent.\n\n- [ ] Implement multi-LLM orchestration (analyst, coder, reviewer roles).\n- [ ] Add scoring metrics to evaluate each iteration (e.g., test pass rate,\n      cyclomatic complexity, etc.).\n- [ ] Create a feedback loop – unsuccessful iterations trigger reflections &\n      corrective actions stored via `memory_manager`.\n\n## Phase 3 – External Integration (future, not started)\n\nGoal: once the agent is robust, begin exploring the *future goal* (SAAS).\n\n- [ ] Research market opportunities.\n- [ ] Prototype minimum-viable product.\n- [ ] …\n"
    }
  ],
  "message_to_human": null
}
