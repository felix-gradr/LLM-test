"""orchestrator.py
High-level module that demonstrates *chained* LLM calls:
    • LightAgent  – cheap `o4-mini` summarisation & pattern-matching.
    • HeavyAgent  – expensive `o3-ver1` deep reasoning / code generation.

The public entry-point is TaskRouter.generate(), which first compresses
large context via LightAgent and then feeds that summary (plus goal) into
HeavyAgent to obtain a Python code-patch (to be executed by root.py).
"""

from __future__ import annotations
from typing import Dict

from llm_helper import ask_o4, ask_o3
import memory


class LightAgent:
    """Wrapper around the lightweight `o4-mini` model."""

    MODEL_NAME = "o4-mini"

    @staticmethod
    def summarise_codebase(snapshot: Dict[str, str]) -> str:
        """Return a condensed summary of *snapshot* suitable for o3 input."""
        joined = "\n".join(f"## {p}\n{c}" for p, c in snapshot.items())
        # Hard cap to stay under context window
        joined = joined[:40_000]
        prompt = (
            "You are tasked with producing a concise yet comprehensive summary " 
            "of a Python codebase so that a more powerful LLM can make informed " 
            "decisions without reading every file.\n\n" 
            "Please summarise the following codebase in <350 words, preserving:\n" 
            "• Key modules & their responsibilities\n" 
            "• Any obvious TODOs / FIXME comments\n" 
            "• Existing tests or CI hooks\n\n" 
            "Codebase follows:\n" 
            f"{joined}"
        )
        summary = ask_o4(prompt)
        memory.add_memory("Generated codebase summary", meta={"kind": "summary"})
        return summary


class HeavyAgent:
    """Wrapper around the heavyweight `o3-ver1` model."""

    MODEL_NAME = "o3-ver1"

    @staticmethod
    def propose_patch(summary: str, goal: str) -> str:
        """Ask the heavy model to propose a Python code-patch.

        The result *must* be a raw Python code block – root.py will `exec` it.
        """
        prompt = (
            f"You are SelfCoder, an autonomous coding agent.\n\n"
            f"Current immutable GOAL:\n{goal}\n\n"
            "You have been provided a high-level summary of the existing " 
            "repository. Using only that summary, decide on the single *most " 
            "useful* incremental change that advances the GOAL – e.g. create " 
            "new modules, refactor, write tests, etc.\n\n" 
            "Respond with **only** a valid Python code block that performs the " 
            "change (using pathlib for cross-platform compatibility).\n\n" 
            "Repository summary:\n" 
            f"{summary}"
        )
        code_block = ask_o3(prompt, temperature=0.0)
        memory.add_memory("Proposed code patch from HeavyAgent", meta={"kind": "patch"})
        return code_block




# ====================== Auto-generated by SelfCoder ======================
import importlib
import textwrap
import re
from llm_helper import ask_o3, ask_o4   # noqa: F401  (ask_o4 reserved for future use)

class WorkerAgent:
    """Lowest-level agent that turns a single assignment into an executable
    Python patch string consumable by root.py.  For v1 it is a thin wrapper
    around an LLM call and will evolve to include tools & validations."""

    def work_on_task(self, task: str, code_summary: str, full_code: str) -> str:
        """Return a raw Python patch (string)."""
        prompt = f"""You are WorkerAgent, part of an autonomous, multi-agent
code-refactoring system.

TASK:
{task}

CODEBASE SUMMARY:
{code_summary}

Respond with ONLY a valid Python code block that applies the required
changes using pathlib.  DO NOT add any explanations or commentary.
"""

        # Use o3 for deeper reasoning power
        response = ask_o3(prompt)

        # Extract the first python code block, if present
        match = re.search(r"""(?:python)?\n(.*?)""", response, re.DOTALL)
        if match:
            return textwrap.dedent(match.group(1))
        # Fallback to raw (already should be code)
        return response.strip()
# ==================== End WorkerAgent definition ======================
class TaskRouter:
    """Simple facade combining Light & Heavy agents."""

    def __init__(self, snapshot: Dict[str, str], goal: str, _system_prompt: str) -> None:
        self.snapshot = snapshot
        self.goal = goal
        self.system_prompt = _system_prompt  # Not used yet but kept for future

    # Public -----------------------------------------------------------------
    def generate(self) -> str:
        """Run the chained call pipeline and return a Python patch string."""
        summary = LightAgent.summarise_codebase(self.snapshot)
        patch_code = HeavyAgent.propose_patch(summary, self.goal)
        return patch_code

    # ==== MULTI AGENT v1 BEGIN ====
        def generate(self) -> str:  # noqa: C901, WPS231 – long method is acceptable here
            """Multi-step patch generation using planning, assignment and worker agents."""
            try:
                from pathlib import Path  # local import keeps global namespace clean
                import json
                import llm_helper  # already part of the repo

                # -------------------------------------------------
                # 1. Cheap repo summary (LightAgent, o4-mini)
                # -------------------------------------------------
                summary = self.light_agent.summarise_repository()

                # -------------------------------------------------
                # 2. High-level strategic plan (PlanningAgent, o3)
                # -------------------------------------------------
                goal_text = Path(__file__).with_name("goal.md").read_text(encoding="utf-8")
                planning_prompt = (
                    "You are the PLANNING agent for a self-developing codebase.\n"
                    "Produce a concise JSON dictionary with one key, 'plan', containing an ordered "
                    "list of high-level actions that move the project towards its immutable goal "
                    "and current sub-goal.\n\n"
                    f"Immutable goal & sub-goal:\n{goal_text}\n"
                    "Repository summary:\n"
                    f"{summary}\n"
                    "Respond with valid JSON ONLY."
                )
                plan_json_raw = llm_helper.ask_o3(planning_prompt)
                plan = json.loads(plan_json_raw).get("plan", [])
                if not plan:
                    raise ValueError("Planning agent returned an empty plan.")

                # -------------------------------------------------
                # 3. Concrete tasks (AssignmentAgent, o3)
                # -------------------------------------------------
                assignment_prompt = (
                    "You are the ASSIGNMENT agent.\n"
                    "Break the following strategic plan into the smallest possible, independent "
                    "coding tasks that can each be executed in a single patch.\n"
                    "Return a JSON list of task strings.\n\n"
                    f"Strategic plan JSON:\n{plan_json_raw}"
                )
                tasks_raw = llm_helper.ask_o3(assignment_prompt)
                tasks = json.loads(tasks_raw)
                if not tasks:
                    raise ValueError("Assignment agent produced no tasks.")
                current_task = tasks[0]

                # -------------------------------------------------
                # 4. Patch for first task (WorkerAgent, o4)
                # -------------------------------------------------
                worker_prompt = (
                    "You are the WORKER agent. Implement the requested change as a Python patch.\n"
                    "The patch MUST:\n"
                    " • Use pathlib for cross-platform file access\n"
                    " • Be enclosed in a single Python code block ( ... )\n"
                    " • Contain NO additional commentary.\n\n"
                    f"Immutable goal & sub-goal:\n{goal_text}\n"
                    f"Repository summary:\n{summary}\n"
                    f"Your task: {current_task}"
                )
                patch = llm_helper.ask_o4(worker_prompt)
                return patch

            except Exception as exc:  # pragma: no cover – safety net
                # If anything fails, fall back to the original single-step behaviour.
                try:
                    return self.heavy_agent.propose_patch()
                except Exception:
                    # Last-ditch effort: surface the error so it gets logged upstream.
                    raise exc
    # ==== MULTI AGENT v1 END ====
    

# ================= SelfCoder multi-agent patch =================
from types import MethodType

def _multi_agent_generate(self) -> str:  # noqa: C901
    """New TaskRouter.generate implementation.

    Pipeline:
        LightAgent  -> PlanningAgent -> AssignmentAgent -> WorkerAgent

    Falls back to the legacy HeavyAgent pipeline upon any error so that
    the system continues to function even if downstream agents are not
    yet fully implemented.
    """
    try:
        # ----------------------------------------------------------
        # 0. High-level summary (LightAgent)
        # ----------------------------------------------------------
        light = LightAgent()
        summary = light.summarise_codebase(self.snapshot)

        # ----------------------------------------------------------
        # 1. Planning phase
        # ----------------------------------------------------------
        planning_mod = importlib.import_module("agents.planning_agent")
        PlannerCls = getattr(planning_mod, "PlanningAgent", None)
        if PlannerCls is None:
            raise RuntimeError("PlanningAgent missing")
        planner = PlannerCls()

        plan = None
        for method_name in ("create_plan", "generate_plan", "plan"):
            if hasattr(planner, method_name):
                plan = getattr(planner, method_name)(summary)
                break
        if not plan:
            raise RuntimeError("PlanningAgent returned no plan")

        # ----------------------------------------------------------
        # 2. Assignment phase
        # ----------------------------------------------------------
        assignment_mod = importlib.import_module("agents.assignment_agent")
        AssignerCls = getattr(assignment_mod, "AssignmentAgent", None)
        if AssignerCls is None:
            raise RuntimeError("AssignmentAgent missing")
        assigner = AssignerCls()

        assignments = None
        for method_name in ("create_assignments", "generate_assignments", "assign"):
            if hasattr(assigner, method_name):
                assignments = getattr(assigner, method_name)(plan)
                break
        if not assignments:
            raise RuntimeError("AssignmentAgent produced no assignments")

        # ----------------------------------------------------------
        # 3. Execution/work phase  (v1: first assignment only)
        # ----------------------------------------------------------
        first_task = assignments[0]
        worker = WorkerAgent()
        # Combine snapshot into a single string for the worker
        full_code = "\n".join(f"## {p}\n{c}" for p, c in self.snapshot.items())
        return worker.work_on_task(first_task, summary, full_code)

    except Exception as err:
        # Graceful degradation to the original HeavyAgent pipeline
        print(f"[TaskRouter] Multi-agent pipeline failed with {err}. "
              "Reverting to single-agent mode.")
        light = LightAgent()
        summary = light.summarise_codebase(self.snapshot)
        heavy = HeavyAgent()
        return heavy.propose_patch(summary, self.goal)

# Attach the new method to TaskRouter
TaskRouter.generate = _multi_agent_generate
# ================= End SelfCoder patch =================
